# Unix基础知识

## 1. Unix体系结构
严格意义：  
  操作系统可被定义成一种软件，控制计算机硬件资源，提供程序的运行环境。  
即为 **内核** 。内核的接口被称为 *系统调用* 。系统调用接口之上是: 公用  
函数库，和shell(一个特殊的应用程序，为其他应用程序提供了接口)。
广义上讲：
  操作系统包括了内核和其他软件，这里的其他软件包括系统实用程序，应用程  
序，shell以及公用函数库等。GUN/Linux系统与之类似。而微软的 Windows中的  
其他软件包括了：桌面，DLL，csrss，svchost，运行库以及其他运行组件。

## 2. 登录

### 1. 登录名
登录系统时，先输入用户名再输入口令(及密码)，系统在口令文件(/etc/passwd)  
中查看登录名，7个冒号隔开。依次是： 登录名:加密口令:数字用户ID:数字组ID  
:注释字段:起始目录:shell程序。(所有的系统都将加密口令移动另一个文件中)
   
    yjh:x:1000:1000:yjh,,,:/home/yjh:/usr/bin/zsh

### 2. shell
 shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入  
通常来自于终端(交互式shell)，有时来自于文件(称为shell脚本)。

## 3. 文件和目录

### 1. 文件系统
Unix文件系统是目录和文件的一种层次结构，所有东西的起点都是称为’根’(名称是' / ')  
目录是一个包含目录项的文件，每个目录项都包含一个文件名和说明该文件属性的信息。  
文件属性包括：文件类型(普通文件还是目录等)，文件大小，文件所有者，文件权限(其他  
用户能否访问该文件)，文件最后修改时间等。

### 2. 文件名
对于文件名理论上只有 *斜线(/)* ， *空字符* ，这两个字符不能出现在文件名中。
(如果非要使用这两个字符可以加上转义字符)， 创建新目录时会自动创建两个文件名：  
. 和 .. 。前者指向当前目录，后者指向父目录。对于根目录，两者都指向当前目录。

### 3. 路径名
由斜线分隔的一个或多个文件名组成的序列(也可以是斜线开头)构成路径名。  
由斜线开头的路径是绝对路径名，相反是相对路径名。  

### 4. 工作目录
每个进程都有一个工作目录，有时称之为 *当前工作目录*。所有相对路径名  
都是从工作目录开始解释。进程可以通过命令 **chdir** 更改其工作目录。  

### 5. 起始目录
登录时，工作目录设置为起始目录，该起始目录从口令文件中相应用户的登录  
项获得。  

## 4. 输入和输出

### 1. 文件描述符
文件描述符通常是一个小的非负整数，内核用以标识一个特定进程正在访问的  
文件。当内核打开一个现有文件或创建一个新文件时，他都返回一个文件描述  
符。在读，写文件时，可以使用这个文件描述符。

### 2. 标准输入，标准输出和标准错误
当运行一个新程序时，所有的shell都为其打开了3个文件描述符，即 *标准输入*，  
*标准输出*， *标准错误*。通常在不做处理的情况下，这三者都指向终端。大多数  
shell都提供一种方法(重定向)，使其中任何一个或所有三个都重新定向到某个文件。  
(ps：可以将终端也理解为一个文件(/dev/tty0))。

### 3. 不带缓冲的I/O
函数open，read，write，lseek以及close提供了不带缓冲的I/O。这些函数都使用  
文件描述符。

### 4. 标准I/O
标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口， 使用标准I/O函  
数无需担心如何选取最佳的缓冲区大小，此外标准I/O函数还简化了对输入行的处理  

## 5. 程序和进程

### 1. 程序
程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec()，将程序读入  
内存，并执行程序。

### 2. 进程和进程ID
进程即为 *程序的执行实例* 。某些操作系统用任务表示正在执行的程序。  
进程ID是每个进程的唯一数字标识符，总是一个非负整数。

### 3. 进程控制
三个主要用于进程控制的函数：fork(), exec()和waitpid()。(exec函数有7中变  
体，但经常把它们统称为exec函数)。

### 4. 线程和线程ID
线程：某一时刻执行的一组机器指令；通常一个进程只有一个控制线程。  
对于某些问题，如果有多个控制线程分别作用于它的不同部分，解决起来  
更方便。多线程可以充分利用多处理系统的并行能力。

## 6. 出错处理

1. Unix系统函数出错时，通常会返回一个复制，而且整型变量errno通常被设置为  
特定信息的值。  
2. 文件< errno.h >中定义了errno以及可以赋与它的各种常量。
3. 支持线程的环境中，多个线程共享进程地址空间。但每个线程都有属于自己的局  
部errno，避免一个线程干扰另一个。
4. errno应当注意的两个规则：
> 1. 如果没有出错，其值不会被例程清除。因此，仅当函数返回值指明出错的时候，  
>    才检验其值。
> 2. 任何函数都不会将errno值设置为0，而且在<errno.h>中定义的所有常量都不为0。  

5. C标准定义了两个函数，它们用于打印出错信息。
> 1. strerror() 函数将 *errnum* (通常就是errno值) 映射为一个出错消息字符串，  
>   并返回此字符串指针。
    ```
    #include <string.h>
    char *strerror(int errnum);
    ```
> 2. perror() 函数基于errno的当前值，在标准错误上产生一条出错信息，然后返回  

    ```
    #include<stdio.h>
    void perror (const char *msg);
    ```
### 出错恢复

< errno.h >中定义的各种出错分为两类： **致命性的** 和 **非致命性**。  
1. 致命性错误无法执行恢复动作，最多在用户屏幕上打印一条出错消息或者将一条  
错误信息写入日志。  
2. 非致命性错误，只要可以较妥善地处理。大多数非致命性出错是暂时的。  
> **非致命性错误包括** ： *EAGAIN*, *ENFILE*, *ENOBUFS*, *ENOLCK*, *ENOSPC*,  
> *EWOULDBLOCK*。 *ENOMEM*有时候也是非致命性错误， *EBUSY* 指明共享资源  
> 正在使用时，也可将其作为非致命性错误， *EINTR* 中断一个慢速系统调用时  
> 也是非致命型错误

## 7. 用户标识

### 1. 用户ID
一个向系统标识各个不同的用户的数值。系统管理员在确定一个用户的登录名的同时  
确定其用户ID，用户不能更改其用户ID。用户ID为0的用户为 *根用户*(root)或 *超  
级用户*(superuser)。

### 2. 组ID
组ID也是由系统管理员在指定用户登录名时分配的数值。位于相同组的用户可以共享  
资源。组文件将组名映射为数值的组ID，组文件通常是/etc/group。

### 3. 附属组ID
除了口令文件中对一个登录名指定一个组ID之外，大多数Unix系统版本还允许一个用户  
属于另一些组。从4.2BSD开始，它允许一个用户属于多至16个其他的组。登录时读取文件  
/etc/group，寻找列有该用户名作为其成员的前16个记录项就可以得到该用户的附属组ID。  

## 8. 信号
信号用于通知进程发生了某种情况。进程有三种处理信号的方式：
> 1. 忽略信号。 (因为后果不确定，所以不推荐)
> 2. 按系统默认方式处理
> 3. 提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。

终端键盘上产生信号的两种方法是：一种方法是 **中断键(通常是Delete或Ctrl+C)**和 **退出键(    
通常是Ctrl+/)**；另一种方法是调用 **kill()函数**。第二种方法有限制：当向一个进程发送信号  
时，我们必须是那个进程的所有者或者是超级用户。 

## 9. 时间值

历史上，unix系统使用过两种不同的时间值。
### 1. 日历时间
   该值是自协调世界时 1970年1月1日 00:00:00 这个特定时间以来所经过的秒数累计值。  
时间值用来记录文件最近一次的修改时间等。
### 2. 进程时间
   又称为cpu时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。美妙  
曾取为 50，60或100个时钟滴答。系统基本数据类型 **clock_t** 保存这种时间值。
当度量一个进程的执行时间时，系统为进程维护了3个进程时间值：
> 1. 时钟时间 (墙上时钟时间)： 进程执行时间的总量。
> 2. 用户cpu时间：执行用户指令所用的时间量。
> 3. 系统cpu时间：该进程执行内核程序所经历的时间。

要取得任一进程的时钟时间，用户时间和系统时间需要执行命令 *time(1)*。

## 10. 系统调用和库函数
**系统调用**：所有操作系统都提供了多种服务的入口点，由此程序向内核请求服务。各种版本  
都提供了良好定义，数量有限，直接进入内核的入口点，这些入口点统称为 *系统调用(system call)*  
> 早期操作系统的系统调用是通过汇编语言定义内核入口点的。各种版本的Unix的系统调用是通过  
> C语言定义的。

### Unix系统调用所使用的技术
系统调用接口使用C语言定义的，这与具体系统如何调用一个系统调用的实现技术无关。  
Unix所使用的技术是 *为每个系统调用在标准C库中设置一个具有相同名字的函数。用户  
用标准C调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。*

    从实现者角度来看，系统调用和库函数有根本的区别，但从用户角度来看，其区别并不重要
    如果有可能，我们可以替换库函数，但系统调用通常是不能替换的。

### 系统调用和库函数区别
1. eg: 对于存储空间分配函数malloc()来说，有多种方法可以进行存储空间分配及与其相关的  
无用空间回收操作，Unix系统调用中处理分配空间的是sbrk(2)，它不是一个通用的存储器管  
理器。它按指定字数增加或减少进程地址控。如何管理该地址空间取决于进程。总的来说，  
内核中的系统调用分配了一块空间给进程，而库函数malloc()则在用户层次管理这一空间。
2. eg: 对于时间的处理，Unix系统只提供了一个系统调用，该系统调用返回自协调世界时  
这个特定时间以来所经过的秒数，对于该数值的解释，都留给了用户处理。而C语言库函数  
提供了很多处理方法的例程。
3. 应用程序即可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。2. eg: 对于时间的处理，Unix系统只提供了一个系统调用，该系统调用返回自协调世界时  
这个特定时间以来所经过的秒数，对于该数值的解释，都留给了用户处理。而C语言库函数  
提供了很多处理方法的例程。
3. 应用程序即可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。
